#pragma once

#include "../Entity/Particle.h"
#include "IParticleForceGenerator.h"
#include "../Defs.h"

namespace Engine
{
	/* f = k(|d| - l0)^d [ |d| = magnitudes of distance between the end of spring, length of spring,
					d = vector from end spring, ^d = direction of other end spring]
		d = Xa - Xb [Xa = pos of the spring attached , Xb other side end spring] */
	class DefaultSpringForceGenerator : public IParticleForceGenerator
	{
	public:

		DefaultSpringForceGenerator(Particle* secondParticle, float stiffness, float restLength);
		~DefaultSpringForceGenerator();

		// Implementation of the forces that are generated by the spring 
		virtual void UpdateForces(Particle* particle);

	private:
		Particle* secondParticle; // The second particle on the other side of the spring
		float stiffness;
		float restLength;
	};

	class DragForceGenerator : public IParticleForceGenerator
	{
	public:
		DragForceGenerator(float k1, float k2);
		~DragForceGenerator();

		virtual void UpdateForces(Particle* particle) override;

		inline void setK1(float k1) { this->k1 = k1; }
		inline void setK2(float k2) { this->k2 = k2; }

	private:
		float k1; // velocity drag coeff.
		float k2; // velocity square drag coeff.
	};

	/*
	Anchored Spring Force Generator
	*/
	class AnchoredSpringForceGenerator : public IParticleForceGenerator
	{
	public:
		AnchoredSpringForceGenerator(glm::vec3* anchorPoint, float stiffness, float restLength);;
		~AnchoredSpringForceGenerator();

		// Implementation of the forces that are generated by the spring 
		virtual void UpdateForces(Particle* particle);

		inline void SetAnchorPoint(glm::vec3* point) { anchorPoint = point; }

	protected:
		glm::vec3* anchorPoint;
		float stiffness;
		float restLength;
	};

	/*Bungee Spring Force Generator*/
	class BungeeSpringForceGenerator : public AnchoredSpringForceGenerator
	{
	public:
		virtual void UpdateForces(Particle* particle) override;

		BungeeSpringForceGenerator(glm::vec3* anchorPoint, float stiffness, float restLength);
		~BungeeSpringForceGenerator();
	};

	/* BUOYANCY FORCE GENERATOR
	   f = mg [f = weight]
	   f = { 0 when d <= 0 , vp when d>=1, dvp = otherwise}
	   s = sumersion depth, p = density, v = volume of obj, d = amount of the obj sumerged
	   d = Y0 -Yw - s / 2s [ y0 = y coord. Yw = coord if liquid plane]
	*/
	class BuoyancyForceGenerator : public IParticleForceGenerator
	{
	public:
		virtual void UpdateForces(Particle* particle) override;

		BuoyancyForceGenerator(float density, float volume, float maxPaticleDepth, float liquidHeight);
		~BuoyancyForceGenerator();

	private:
		//LiquidProperties;
		float liquidHeight; // The y coordinate of the liquid's plane (assuming that plane is parallel to XZ plane)
		float maxParticleDepth; // The max depth after which the object is said to be completely submerged 
		float volume;
		float liquidDensity;
	};

	///*
	//Harmonic motion 
	//the position of one end of the spring :p = -x^2 p , x = √(k/m) [diferential equation (:p - p)]
	//p(t) = p0 cos(xt) + (·p0 / x)sin(xt) [po = pos end spring realtive to natural length at start of the prediction, ·p0 = vel at same time ]
	//the force f = m(:p) , acce (:p) = (pt - p0) 1/t^2 - ·p0.

	//Damped HarmonicMotion
	//damped harmonic oscillator, the differenctial equation :p = -kp -d·p [d = drag corff]
	//differential equation for the position at any time pt[p0 cos(γt) + csin(γt)] e ^-1/2 dt
	//γ = 1/2√(4k - d^2), c = d/2γ p0 + 1/γ·p0
	//*/
	//class FakeSpringForceGenerator : IParticleForceGenerator
	//{
	//public:
	//	virtual void UpdateForces(Particle* particle) override;

	//	FakeSpringForceGenerator(glm::vec3* anchorPoint, float springStiffness, float springDamping);
	//	~FakeSpringForceGenerator();

	//	inline void SetAnchorPoint(glm::vec3* point) { anchorPoint = point; }
	//private:
	//	glm::vec3* anchorPoint; // Anchor point that the spring is hung from
	//	float springDamping; // Damping caused by by the spring forces
	//	float springStiffness; // Stiffness constant of the spring
	//};

}